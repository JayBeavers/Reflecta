<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Reflecta : Arduino communications protocol focusing on remote access to GPIO and I2c and remote function calls" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Reflecta</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/JayBeavers/Reflecta">View on GitHub</a>

          <h1 id="project_title">Reflecta</h1>
          <h2 id="project_tagline">Arduino communications protocol focusing on remote access to GPIO and I2c and remote function calls</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/JayBeavers/Reflecta/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/JayBeavers/Reflecta/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p><strong>Reflecta</strong> is a communications library for Arduino that enables remote calling of functions, sending &amp; receiving frames of byte data or string messages, and receiving high speed 'heartbeats' of sensor data.</p>

<hr><h2>Getting Started</h2>

<p>To install, download the contents of the repository as a zip file and decompress into your <a href="http://arduino.cc/it/Reference/Libraries">'sketchbook' folder</a> (on Windows this is My Documents -&gt; arduino) in a subdirectory named 'libraries'.  When you are done you should have a file like My Documents\arduino\libraries\ReflectaFramesSerial\ReflectaFramesSerial.h.  Now you can restart the Arduino IDE and use Sketch -&gt; Import Library.</p>

<p><strong>Examples</strong></p>

<p><a href="https://github.com/JayBeavers/Reflecta/blob/master/Samples/BasicReflecta/BasicReflecta.ino">BasicReflecta</a> -- opens a Reflecta listener at 9600 baud and exposes the Arduino Core functions to be called.  This is the 'Arduino side' of the conversation.</p>

<p><a href="https://github.com/JayBeavers/Reflecta/tree/master/NodeClient">NodeClient</a> -- a <a href="http://nodejs.org/">NodeJS</a> library that will talk to BasicReflecta and call Arduino functions such as digitalWrite.  See <a href="https://github.com/JayBeavers/Reflecta/blob/master/NodeClient/samples/simple.js">simple.js sample</a> as an example.</p>

<h2>Why?</h2>

<p>Arduino easily connects to a PC over USB as a Virtual COM port but turning this serial data stream into a reliable communications channel takes considerable work.  Firmata is a comparable library but it has some limitations:</p>

<ul>
<li><p>Firmata is based on MIDI and uses a '7 bit data' design.  The 8th bit is reserved for 'commands' so all raw data sent over the wire has to be converted to/from 7 bits.</p></li>
<li><p>Firmata is difficult to extend with new methods due to its SYSEX design and 7-bitness.</p></li>
<li><p>Firmata doesn't detect corrupt or lost data.  Testing using USB Virtual COM with two-chip (USB chip -&gt; UART -&gt; MCU chip) boards like the UNO detected frequent data corruption at speeds over 9600 baud.  RF communications like Bluetooth or Zigbee need to be able to detect data loss and corruption in order to modify their sending behavior based on changing physical conditions such as antenna blockage or distance.</p></li>
</ul><p>The goal is to develop a protocol that fixes these issues, specifically:</p>

<ul>
<li><p>Use 'escaping' to delineate frames so we don't need to convert payload data to 7 bits.</p></li>
<li><p>Add Sequence and Checksum to detect data loss and corruption.</p></li>
<li><p>Make it easy to extend the protocol with new functions (bind) and discover what functions are implemented (queryinterface).  Minimize the amount of work needed for a library to be exposed for remote calling.</p></li>
<li><p>Design for CPU and communications efficiency in order to take best advantage of limited microcontroller resources.</p></li>
</ul><h2>How?</h2>

<p>Reflecta is four Arduino libraries and one NodeJS client:</p>

<ul>
<li><p><a href="https://github.com/JayBeavers/Reflecta/tree/master/ReflectaFramesSerial">ReflectaFramesSerial</a> packages byte[] data into frames over a stream, adds Sequence to detect lost frames, and adds Checksum to detect data corruption. Uses the Arduino Serial library for communications, a future Raw Hid implementation is planned.</p></li>
<li>
<p><a href="https://github.com/JayBeavers/Reflecta/tree/master/ReflectaFunctions">ReflectaFunctions</a> is a remote function calling protocol that builds on top of ReflectaFrames.  Arduino functions are registered by calling <em>bind(interfaceId, function pointer)</em>.</p>

<p>ReflectaFunctions uses a stack-based approach to calling functions. push() parameters on the stack, invoke function(s), functions pop() their parameters off the stack and push() their return values back on.</p>

<p>ReflectaFunctions exposes bind() and queryInterface() to determine which interfaces (e.g. function groups) are on the Arduino.</p>
</li>
<li><p><a href="https://github.com/JayBeavers/Reflecta/tree/master/ReflectaArduinoCore">ReflectaArduinoCore</a> is a binding of the Arduino core library functions such as pinMode, digitalRead, analogWrite to the 'ARDU1' interface.</p></li>
<li><p><a href="https://github.com/JayBeavers/Reflecta/tree/master/ReflectaHeartbeat">ReflectaHeartbeat</a> is a library for reading digital and analog pins very efficienctly, calling functions and gathering their results into a data packet, and sending the results at a fixed frequency to the host PC.  ReflectaHeartbeat is optimized to quickly gather data off the Arduino while effectively sharing the CPU by using asynchronous polling inside loop() rather than delay().</p></li>
<li><p><a href="https://github.com/JayBeavers/Reflecta/tree/master/NodeClient">NodeClient</a> is a NodeJS library built on top of node-serialport.  NodeClient uses ReflectaFunctions to queryInterface and dynamically load javascript objects for the Arduino libraries.</p></li>
</ul><hr><h2>Design</h2>

<p>After reviewing existing technologies, the approach settled on is:</p>

<ul>
<li>Start with the <a href="http://www.atmel.com/Images/doc2591.pdf">STK500 protocol</a> from Atmel which has MESSAGE_START, SEQUENCE_NUMBER, and a simple 8 bit xor CHECKSUM.</li>
<li>STK500 doesn't escape the data, so substitute <a href="http://www.ietf.org/rfc/rfc1055.txt">SLIP framing</a> for the STK500 message start/message size design.  SLIP is very simple to understand and code.</li>
</ul><h3>SLIP In A Nutshell</h3>

<p>SLIP (Serial Line IP) is an <a href="http://www.ietf.org/rfc/rfc1055.txt">IETF standard</a> developed to send network packets over a serial line.  SLIP defines two special characters, <strong>END</strong> (0xC0) and <strong>ESCAPE</strong> (0xDB), that must be escaped if they are found in the payload data.  The pseudocode for SLIP encoding is:</p>

<pre><code>for each byte in payload[]

    if byte == ESCAPE (0xDB) write ESCAPE (0xDB) + ESCAPED_ESCAPE (0xDD)

    else if byte == END (0xC0) write ESCAPE (0xDB) + ESCAPED_END (0xDC)

    else write byte

write END (0xC0)
</code></pre>

<h3>Frame Layout</h3>

<p>Over the wire, a frame of data looks like:</p>

<pre><code>Sequence Payload[] Checksum END
</code></pre>

<p><strong>Sequence</strong> is a byte that increments on each frame sent and rolls over from 255 back to 0.</p>

<p><strong>Payload[]</strong> is the data bytes you want to transfer.</p>

<p><strong>Checksum</strong> is calculated using XOR ( ^= ) on each unescaped byte of Sequence and Payload[].  Checksum is validated by calling XOR on each byte of the incoming frame such that when the END character is reached, the current value of the calculated checksum should be zero because the frame's checksum just XORed with itself.</p>

<p>This compares well to STK500 and Firmata in efficiency (only 3 byte overhead per message) and ease of calculation.  The length of payload is inferred from the length between END characters rather than encoded into the frame.</p>

<hr><h2>Projects using Reflecta</h2>

<p><a href="https://github.com/JayBeavers/RocketBot">RocketBot</a> is a robot built around a Parallax Eddie chassis that adds a pneumatic straw rocket launcher and blinky lights.  It was created for Maker Faire 2012 in San Mateo CA and Seattle WA.</p>

<h2>Futures</h2>

<p>See <a href="https://trello.com/board/reflecta/4fe0b182caf51043640db94b">this Trello Board</a> for planned work.</p>

<h2>Blogs</h2>

<p><a href="http://blog.jaybeavers.org/">Jay Beavers' blog</a> on Reflecta and RocketBot.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Reflecta maintained by <a href="https://github.com/JayBeavers">JayBeavers</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-32935284-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
